lets start by just having a set of tracks, like the normal player, except these will loop
each track should loop on its own, (i.e. if one track's pattern is 1 bar, and another is 2 bars,
the first track will play twice for every time the 2nd bar plays once, rather than waiting for all
patterns to end, then restarting.


* things that can change during the process of playing (stuff we need atoms or something for):
- tracks as a whole (can add / remove (really muting probably makes more sense than removing))
** track specifics
   - muted?
   - volume
     - complicated, maybe should be controlled at the inst level, which we could do , by sending midi
       control info
   - pattern itself
   - instrument fn eventually, low prio
   - volume (complicated, tackle later)

** playing? state
  - should be able to pause / play / restart / skip, ideally using midi sysex signals
  - so this is like location of marker, if we're we looping it can't be longer than
    the longest pattern. it may be useful to track the number of loops as well
  - Overtone's metronome thing can probably be integrated here somehow

** instruments
   - should be tracked separately from tracks, right now inst-fns on tracks
     - should they? I thought this initially because multiple tracks could play the same inst,
       but I think if we want to do future midi stuff, we will probably want to have unique channels
       to the software insts. Let's leave it on the track, and see how that works out
     - ooh, what might make more sense is to store a key referencing the software inst, (e.g. :zynaddsubfx)
       along with the channel. This lets us easily to crazy midi controls knowing the destination of the
       inst. We also retain a "data-only" map, without functions, which is easier to work with

       We can hardcode the insts for now, but they should be in state eventually

   - tracks should instead reference the key of the inst-fn stored in the insts map.
